
<h1 style="text-align:center">Xilinx 7系列FPGA：固件设计</h1>

--------------------------------------------------------------------------------
相关文档:
| 文档名称                                                       | 文档编号 |
| :------------------------------------------------------------- | :------- |
| UltraFast Design Methodology Guide for the Vivado Design Suite | UG949    |

--------------------------------------------------------------------------------
# 1. 设计输入

## 1.1. 时钟设计
1. GSR 之后会释放 Global Enable, GWE。为了保证GWE安全释放，可以：
    * 可以在GWE释放后推迟Clock一段时间。方法：使用BUFG，BUFHCE 或 BUFR 组件，用使能推迟一段时间；如果使用 MMCM，选中 Safe Clock Startup 选项；
    * 可以使用时钟使能、本地复位、或 FSM 保证启动可控

## 1.2. 复位与使能设计
1. ==Xilinx推荐使用同步复位，不得不用异步复位时，建议使用异步复位同步释放==
1. ==Xilinx推荐控制信号（复位、使能等）高电平有效（因为其内部触发器都是高电平有效）==
    * 对于UltraScale器件，Xilinx提供一个可编程的反相
1. Xilinx建议在能不使用复位、使能时，尽量不用
1. Xilinx不建议在一个always模块中同时使用复位和置位
1. Xilinx在FPGA配置后使用global set/reset signals (GSR)对所有同步元素进行初始化，如果没有指定，默认初始为0
1. 仅在需要时使用寄存器的CE。如果不满足条件时，数据无关紧要，这种情况下建议不要使用CE，而是通过else语句将数据切换到0或1
1. Xilinx建议Coding时，先写同步复位，后写使能语句；

## 1.3. 逻辑设计与FPGA资源的对应关系
1. 2位以上的（两元或三元）加减法会使用进位链，每位（两元或三元）加法使用一个LUT；
1. 乘法会使用DSP模块；
1. 短的SRL会使用LUT实现；
1. MUX的实现
    * 4-to-1 MUX用LUT实现；
    * 8-to-1 MUX用一级LUT + 一个MUXF7实现，延时为一个LUT级；
    * 16-to-1 MUX用一级LUT + 几个MUXF7 + 几个MUXF8实现，延时为一个LUT级；
## 1.4. RAM的使用
1. 建议使用输出流水线寄存器：BRAM输出寄存器（永远BRAM逻辑优化） + slice输出寄存器（用于和用户逻辑匹配），读周期将会是3个clk；
1. 少量的RAM会使用LUTRAM实现；

## 1.5. FIFO的使用

## 1.6. DSP的使用
1. 除非必须，不要使用置位（为所用的信号置逻辑1）；
1. DSP仅支持同步复位，避免使用异步复位；
1. DSP使用有符号运算，无符号数运算时不能使用所有位，例如乘法将由25x18变为24*17；

## 1.7. SRL的使用
1. SRL仅支持左移，有Clock Enable信号，没有复位信号；
1. 支持动态长度；
1. 建议将SRL的最后一级连至一个Slice寄存器，一般综合器会自动插入；
1. 可以用SHREG_EXTRACT = “no” 禁用SRL提取；

## 1.8. 初始化
1. GSR会初始化到所需的状态，包含寄存器、FSM初始态、SRL、Memory等；
1. 建议在代码中初始化所有的同步元素，既省去了外部复位步骤，又可以直接进行仿真，初始化方式：
    ```verilog
    // 方式1
    reg [3:0] register3 = 4'b1011;
    // 方式2
    reg [3:0] register3;
    initial begin
    register3= 4'b1011;
    end
    ```
## 1.9. 时钟域
1. 异步时钟域的信号需要被同步化；可用ASYNC_REG属性优化同步链，例如
    ```verilog
    (* ASYNC_REG = "TRUE" *) reg [SYNC_STAGES-1:0] sync_regs = {SYNC_STAGES{1’b1}};
    ```

--------------------------------------------------------------------------------
# 2. Implementation

## 2.1. constrains
1. 在Vivado中，每个时钟（主时钟以及产生的时钟）、时钟之间的关系都要约束，除非明确为异步时钟或错误路径；
1. IP核在例化时会产生时钟约束，但优先使用用户设置的约束。

